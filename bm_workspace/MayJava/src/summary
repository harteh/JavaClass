JDK / 이클립스 설치
- JDK
	java11 > 운영체제에 맞는 버전을 다운로드 > 오라클 계정 로그인 > 설치 후 확인 C: > 프로그램파일> 자바 폴더에 설치 완료됨 
	- 이클립스(Eclipse IDE for Enterprise Java and Web Developers 2021)
- path 설정
	pc> 속성 > 설정 > 고급시스템설정 > 환경변수 > 시스템변수 > path > 새로만들기 > 최상단으로 이동 > 저장(확인) > 이클립스 재가동
	[C: > 프로그램폴더 > 자바 > jdk > bin :: path]

** 자바 가상 기계(JVM : Java Virtual Machine)
	각기 다른 플랫폼에 설치, 동일한 자바 실행 환경 제공 하기때문에 각각 다른 OS에 적용이 가능함.
	자바 가상 기계 자체는 플랫폼에 종속적
	- 자바 가상 기계는 플랫폼마다 각각 작성됨
	운영체제가 달라도 동일한 코드로 실행됨

소스코드(Test.java) > 자바 컴파일러(Test.class) > 바이트 코드 > 자바 가상 기계 > 운영체제:실행

* JDK : 자바 응용 개발 환경, 개발에 필요한 도구 포함 ( JRE, JVM 포함)
* JRE : 자바 실행 환경, JVM 포함

자바의 특성(1)
	객체지향
		클래스 계층 구조, 상속성, 다형성, 캡슐화 등 지원
		객체의 속성(변수)과 기능(함수)을 구분하여 코드를 작성한다.
	멀티스레드(일꾼)
		다수 스레드의 동시 수행 환경 지원
		자바는 운영체제의 도움 없이 자체적으로 멀티스레드 지원
	플랫폼 독립성
		자바 가상 기계가 바이트 코드 실행
	소스와 클래스 파일
		하나의 소스 파일에 여러 클래스를 작성 가능
		하나의 public 클래스만 가능
자바의 특성(2)
	실행모듈
	main() 메소드에서 시작

자바의 데이터 타입
	boolean (0,1 : false, true)* : 1바이트(8bit)
	char 	: 문자* : 2바이트
	byte 	: 정수 	: 1바이트
	short : 정수 	: 2바이트
	int 	: 정수* : 4바이트
	long 	: 정수 	: 8바이트
	float  : 실수  : 4바이트
	double : 실수* : 8바이트

	레퍼런스 타입(클래스, 인터페이스, 배열)
	
반복문 무한루프
	while(true) {}
	for(;;) {}
	for(int i=1;;i++) {}
	- while문에서 많이 쓰임
	- 프로그램의 정상적인 실행이 아님
	- 무한루프를 빠져나오기 위해서 break 제어문자가 필요하다.
	
	※ break
	반복문 하나를 완전히 빠져나갈 때 사용
	break 문은 하나의 반복문만 벗어난다.
	- 중첩 반복의 경우 안쪽 반복문의 break문이 실행되면 안쪽 반복문만 벗어난다.

	※ continue
	반복문을 빠져나가지 않는다.
	- 반복문 실행 도중 다음 반복을 진행한다
	
배열
	한번에 많은 메모리 공간 선언이 가능하다.
	같은 타입의 데이터들이 순차적으로 저장된다.
	배열의 인덱스는 0 부터 시작한다.
	
	배열의 선언 
		int a[];
	배열 초기화
		int arr[] = {};
	배열의 크기
		배열명.length
		배열의 크기는 수정되지 않는다.
		
	int ary[] = new int[10]
	- 자료형 배열명[] = new 자료형[데이터개수]
	- '배열 선언' = '배열 생성'
	- int형 데이터가 10개인 배열 : 40바이트

이차원배열
	행과 열로 이루어져 있다.
	int arr[][]
	arr = new int[2][5];
	=> int arr[][] = new int[2][5]
	
객체배열
	객체에 대한 레퍼런스를 원소로 갖는 배열
	Book b[];    		// Book 배열에 대한 레퍼런스 변수 b 선언
	b = new Book[5];    //레퍼런스 배열 생성		
	
문자열
	split(String regex)
	  - split 메소드는 문자열을 특정 구분자로 분리하는 메소드이다.
	  - Splits this string around matches of the given regular expression.
   
	substring(int beginIndex, int endIndex)
	  - substring은 문자열 중 특정 부분을 뽑아낼 경우에 사용한다
	  - Returns a string that is a substring of this string.
   
	replace(char oldChar, char newChar)
	  - 문자열 대체
	  - Returns a string resulting from replacing all occurrences of oldChar 
	    in this string with newChar.
   
	concat(String str)
	  - 문자열 연결
	  - Concatenates the specified string to the end of this string. 
   
	length()
	  - 문자열 길이
	  - Returns the length of this string.
   
	compareTo(String anotherString)
	  - 두 문자열을 비교
	  - Compares two strings lexicographically.
	
함수
	반환형 함수명(매개변수){}
	자바의 모든 메서드는 반드시 클래스 안에 있어야 한다 = 캡슐화
	
	접근지정자
		: public, private, protected, default(접근지정자가 생략된 경우)
	static 
		: 클래스 안에서 함수를 공유할 수 있다.
	void 
		: 반환형 = 돌려받을 값, 반환할 자료형을 기입
	return 
		: 반환 값
	
	※ 함수 만들기
	1. 출력을 어디에서 할건지 결정한다.
	2. main에서 출력할 경우 함수에서 리턴값을 받아야 한다.
	  → 함수호출과 동시에 출력
	  → 변수를 주면서 리턴값을 저장할 것인지.
	2-1. 함수에서 출력 할 경우 리턴문이 필요없다.
	  → (void)

비트연산자
	비트(bit) 단위로 논리 연산을 할 때 사용한다
	bit는 최소단위로 재현 과정을 거치지 않고 즉시 해석되어 의미를 전달하기 때문에,  빠른 속도라는 장점을 가진다.
	
	| (OR연산자)	피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 그 외에는 0을 얻는다.
	& (AND연산자)	피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.
	^ (XOR연산자)	피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 그 외에는 0을 얻는다.
	
비트 전환 연산자 ~
	피연산자를 2진수로 표현했을 때, 0은 1로, 1은 0으로 바꾼다.
	논리부정 연산자 '!'와 유사하다.
	
	비트 전환 연산자에 의해 '비트 전환'이 되고, 부호있는 타입의 피연산자는 부호가 반대로 변경된다. 
	→ 피연산자의 '1의 보수'를 얻을 수 있다.
	
쉬프트 연산자  ≪ ≫
	피연산자의 각 자리(2진수로 표현했을 때)를 오른쪽 또는 왼쪽으로 이동한다.
	
2의 보수
	n비트의 2진수로 표현할 수 있는 값의 개수 
		→ 2의 n승 	→ 4비트의 2진수 = 16개  
		= (부호없는 정수)0부터 15까지의 정수를 나타낼 수 있다.
	양수의 첫 번째 비트만 1로 바꾸면 음수가 되지만, 
		두 수를 더했을 때 2진수로 0이 되지 않는다. 그리고 0이 두 개(0, -0)존재하게 된다.
	2의 보수법에 의해 음수를 배치하면, 모순이 없어진다.
	n의 보수
		더했을 때 n이 되는 수
	2의 보수법
		두 2진수로 절대값이 같고 부호가 다른 두 10진수를 표현한것 → 부호있는 정수를 표현한다.
	2의 보수 = 1의 보수 + 1
	1의 보수 = 0을 1로, 1을 0으로 바꾸면 된다
		2진수에 1의 보수를 더하면 모든 자리가 1이 된다.
		양 변애 1을 더하면 우변은 0이 되고, 올림 되지만 4비트를 넘게되어 저장할 공간이 없어 버려진다.
		어떤 수에 '1의 보수 +1'을 더하면 0이 되므로 '1의 보수 +1'은 '2의 보수'와 같다.
	음수의 2진 표현 구하는 방법
		① 음수의 절대값을 2진수로 변환한다.
		    : -5 → 5의 2진수 '0101'
		② ①에서 구한 2진수의 '1의 보수'를 구한다.
		    : '0101' → '1010'
		③ ②의 결과에 1을 더해 '2의 보수'를 구한다.
		    : '1011' = -5의 2진 표현

입출력스트림
	응용프로그램과 입출력장치를 연결하는 소프트웨어 모듈
	입력 → 입력스트림 → 자바응용프로그램 → 출력스트림 → 출력
	
	 입력받는 상황
	 1. Scanner
	 2. InputStreamReader(많이 쓰임)

입력스트림 
	어떤 대상으로부터 자료를 읽어 들일 때 사용하는 스트림
	FileInputStreamⓑ㉮, FileReaderⓢ㉮, BufferedInputStreamⓑ, BufferedReaderⓢ
	
출력스트림
	편집 화면에 사용자가 쓴 글을 파일에 저장할 때 사용
	스트림은 단방향이여서 입력과 출력을 동시에 할 수 없다.
	FileOutputStreamⓑ㉮, FileWriterⓢ㉮, BufferedOutputStreamⓑ, BufferedWriterⓢ
	
* 주인공(기반스트림) vs 장식(보조스트림) *
  	Constructors의 매개변수를 보고 확인가능하다.	
	기반스트림㉮ : 자료를 직접 읽거나 쓰는 기능이 제공된다
	보조스트림㉳ : 직접 읽거나 쓰는 기능 없이 다른 스트림에 부가기능을 제공한다
		보조스트림은 실제 데이터를 주고받는 스트림이 아니기 때문에 데이터를 입출력할 수 있는 기능은 없지만, 
		스트림의 기능을 향상시키거나 새로운 기능을 추가할 수 있다.
			→ 먼저 기반스트림을 생성한다.
				FileInputStream fis = new FileInputStream("test.text");
			→ 기반스트림을 이용해서 보조스트림을 생성한다.
				BufferedInputStream bis = new BufferedInputStream(fis);
			→ 보조스트림인 BufferedInputStream으로부터 데이터를 읽는다.
				bis.read();
	
바이트기반 스트림
	InputStream, OutputStream
	→ 입출력의 단위가 1 byte
	→ 스트림을 사용해서 모든 작업을 마치고 난 후에는 close()를 호출해서 반드시 닫아 주어야 한다.
	  (예외: 메모리를 사용하는 스트림, 표준입출력 스트림)
	바이트 단위ⓑ로 파일을 읽거나 쓰게되면 한글 같은 문자가 깨지게 된다. 그때는 문자단위스트림ⓢ을 사용한다.
	
	InputStream
		바이트 단위로 읽는 스트림 중 최상위 스트림
		OutputStream, Reader, Writer와 더불어 추상 클래스이다. 
		하위클래스가 구현해야 할 추상 메서드가 선언되어 있다
		

문자기반 스트림
	Reader, Writer
	한 문자를 의미하는 char형이 2byte이기 때문에 바이트기반 스트림으로는 2byte 문자 처리가 어렵다.
	→ 여러 종류의 인코딩과 자바에서 사용하는 유니코드(UTF-16)간의 변환을 자동처리해준다.

  1. 파일 생성(출력)
      Writer(문자단위 파일생성)
      OutputStream(바이트단위 파일 생성)
  2. 파일에다 값 저장
      write 메소드
  3. 파일 읽어들임
      Reader(문자단위로 읽어들임)
      InputStream(바이트단위로 읽어들임)
  4. 파일 닫기
      close()
      
this
	this() 는 반드시 생성자의 첫번째 문장에 위치해야한다.
	this() 는 반드시 같은 클래스의 다른 생성자를 호출할 때 사용된다.
	this() 는 생성자에서만 사용된다.
	
	기본생성자가 먼저 실행된다
	생성자는 void가 있을 수 없다
	
상속
	상속을 이용하는 이유
	- 클래스 사이에 변수를 중복 선언하지 않아도 된다 (클래스의 간결화)
	- 계층적으로 분류 할 수 있다 (클래스 관리의 용이)
	- 클래스 재사용과 확장
	
	자식 생성자를 만들 때 부모생성자 호출을 첫번째에 적어야 한다.
	생성자가 하나 있으면 기본 생성자가 만들어 지지 않는다.
	매개변수를 가진 생성자의 경우 부모 클래스의 기본생성자가 가장 먼저 호출된다.
	
	자바클래스 상속
		하나의 부모클래스 상속가능
		다중상속 불가능
	인터페이스 상속
		다중상속 가능
		extends 예약어 사용하여 같은 인터페이스를 다중상속 가능
		implements 예약어 사용하면 추상메서드를 구현해야만 한다.
	
protected 
	같은 패키지 클래스에 접근 가능
	다른 패키지 클래스에 접근 불가능
	같은 패키지의 서브 클래스에 접근 가능
	다른 패키지의 서브 클래스에 접근 가능 : 상속개념..
	
super
	예약어로 매개변수가 있는 생성자 호출하기
	디폴트 생성자가 아닌 매개변수가 있는 생성자를 직접 구현해야 한다.
	어떤 생성자를 호출할 것인지 명시하는 예약어
	
오버로딩
	같은 클래스나 상속관계에서 동일한 이름의 메소드를 중복 작성한다.
	이름이 같은 여러개의 메소드를 중복 선언하여 사용 편리성이 향상된다.
	메서드 이름은 반드시 동일해야 하며, 메서드의 매개변수의 개수, 타입이 달라야 성립된다.
	정적 바인딩이다. 컴파일 시에 중복된 메서드 중 호출되는 메서드 결정한다.
      
오버라이딩(재정의)
	서브 클래스에서 슈퍼클래스에 있는 메서드와 동일한 이름의 메서드를 재작성 하는 것
	상속관계여야 한다.
	슈퍼클래스에 구현된 메서드를 무시하고 서브클래스에서 새로운 기능의 메서드를 재정의한다.
	메서드 이름, 매개변수 타입, 개수, 리턴타입이 모두 동일해야 한다.
	동적 바인딩, 실행 시간에 오버라이딩된 메서드를 찾아 호출한다.
	
다형성
	여러 가지 형태를 가질 수 있는 능력
	한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 하여 구현.
	부모클래스 타입의 참조변수로 자식클래스의 인스턴스를 참조할 수 있도록 한다.
	
	참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.
	→ 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 
	  존재하지 않는 멤버를 사용하고자 할 가능성이 있으므로 허용하지 않는다.

참조변수의 형변환
	자손타입 → 조상타입 (Up-casting) 	: 형변환 생략가능
	조상타입 → 자손타입 (Down-casting) : 형변환 생략불가
	
	형변환은 참조변수의 타입을 변환하는 것으로 인스턴스에 아무런 영향을 미치지 않는다.
		단지, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것 뿐이다.
	업캐스팅되었을 때 오버라이딩(재정의된 메서드)가 있을때, 오버라이딩된 메서드가 호출된다.
		만들어진 객체의 메서드가 호출되는 것
		
동적바인딩(dynamic binding)		= 가상함수
	실행할 메서드를 컴파일 할때 결정하지 않고 실행 시(run time)에 결정하는 것
	자바에서는 동적 바인딩을 통해 오버라이딩된 메서드가 항상 실행되도록 보장한다.
	
	동적바인딩에 의해 항상 자식 클래스에 오버라이딩한 메소드가 호출됨
		그럼 부모 클래스의 메서드는 더이상 쓸 수 없는가?
		아니다. super키워드를 이용해 정적바인딩을 하여 부모 클래스의 멤버에 접근 가능하다.
		
instanceof 연산자
	참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용, 주로 조건문에 사용된다.
	true 와 false 중 하나를 반환한다.
	다운캐스팅을 하기 전에 상위 클래스로 형변환된 인스턴스의 원래 자료형을 확인해야 변환할 때 오류를 막을 수 있다.
      
추상클래스
	상속을 통해서 자손클래스에 의해서만 완성된다.
	미완성 설계도로 완성된 제품을 만들 수 없듯이 추상클래스로 인스턴스는 생성할 수 없다
		1. 추상 메서드를 최소 한개 이상 가지고 abstract 로 선언된 클래스
		2. 추상 메서드가 없어도 abstract 로 선언된 클래스
			추상메서드를 포함한 것 이외에는 일반 클래스와 동일하다.	
추상메서드
	선언부만 작성하고 구현부는 작성하지 않은것.
	메서드의 내용이 상속받은 클래스에 따라 달라질 수 있기때문
		일반 클래스 안에 들어갈 수 없고 반드시 추상 클래스 안에 있어야 한다

추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
구체화 : 상속을 통해 클래스를 구현, 확장하는 작업

인터페이스
	다른 클래스를 작성할 때 기본이 되는 틀을 제공한다.
	클라이언트 프로그램에 어떤 메서드를 제공하는지 미리 알려주는 명세(specification)
		추상메서드와 상수로만 이루어져있다.
		자바8에 새롭게 추가된 디폴트 메서드와 정적메서드 구현부()implementation part)가 없다면 그냥 껍데기이다.
		default라는 예약어를 적지 않으면 다 추상메소드로 인식한다.
	인터페이스를 이용한 다중상속을 가능하게 한다.
	함수 구현을 강제하여 구현객체에 같은 동작을 강제한다.

Object 클래스
	java.lang.Object : 모든 자바 클래스의 최상위 클래스
	String toString()
	boolean equals(Object obj)
	void wait()
	void notify()
toString( ) 메서드
	인스턴스 정보를 문자열로 반환하는 메서드
	원형: 생성된 인스턴스의 클래스 이름과 주소값을 반환
	String이나 Integer 등 여러 JDK 클래스에서 이미 재정의 되어있다.
		Wrapper 클래스로 boxing 하여 사용?
		
StringBuffer
	문자열을 연결하거나 변경할 경우 사용
	문자의 개수에 따라 버퍼 크기를 자동으로 조절할 수 있다.
	문자열이 길거나 작업이 많은 경우에 사용

예외처리
try블럭 내에서 예외가 발생한 경우
	1. 발생한 예외와 일치하는 catch블럭이 있는지 확인한다.
	2. 일치하는 catch블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고
	  전체 try-catch 문을 빠져나가서 그 다음 문장을 계속해서 수행한다.
	  만약 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.

예외 발생시키기
	1. 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든 다음
	2. 키워드 throw를 이용해서 예외를 발생시킨다.
	
메서드에 예외 선언하기
	void method() throws Exception1, Exception2, ... ExceptionN { 메서드 내용 }
	
	자신(예외가 발생할 가능성이 있는 메서드)을 호출한 메서드에게 예외를 전달하여 예외처리를 떠맡기는 것.
		이는 예외가 처리된 것이 아니라, 단순히 전달만 하는 것으로 
		결국 어느 한 곳에서는 반드시 try-catch문으로 예외처리를 해주어야 한다.

사용자정의 예외 만들기
	보통 Exception 클래스 또는 RuntimeExcpetion 클래스를 상속받아 클래스를 만든다.
	
예외 되던지기
	한 메서드에서 발생할 수 있는 예외가 여럿인 경우,
	하나의 예외에 대해서 예외가 발생한 메서드와 이를 호출한 메서드 양쪽 모두에서 처리해줘야 할 작업이 있을 때 사용
		예외가 발생할 메서드에서는 try-catch문을 사용해서 예외처리를 해줌과 동시에 
		메서드의 선언부에 발생할 예외를 throws에 지정해줘야 한다.

멀티태스킹
	하나의 응용프로그램이 여러 개의 작업을 동시에 처리
프로세스
	응용프로그램을 실행하는 하나의 단위. 
	자바에서는 프로세스 개념이 존재하지 않는다.	대신, 스레드 개념이 존재한다.
스레드
	(thread) : 실행단위
	하나의 응용프로그램은 여러개의 스레드로 구성가능
	하나의 JVM은 하나의 자바 응용프로그램만 실행한다.
	소켓으로 JVM끼리 연결가능
	JVM에서 스레드를 하나하나 관리해줄 수 있다.
	스레드 실행 순서는 랜덤
	
	스레드 만드는 방법: 
	1. Thread 클래스 상속받아 이용
		Thread 를 상속하면 run 메서드를 구현해야 한다
		스레드 코드 = 스레드 실행 시작 메서드
	
		start()로 쓰레드를 실행한다.
		스레드로 작동 시작(JVM에 의해 스케쥴되기 시작함
	
		sleep(100); 
		0.1초 간격으로 재운다..
	
		join();
		쓰레드가 종료할 때까지 기다린다.
	2. Runnable 인터페이스 이용 (주로 사용한다.)
		왜냐하면 Thread 클래스를 상속하면 다른 클래스를 상속할 수 없기 때문
		public void run() 추상메서드를 재정의하여 사용한다.

synchronized
	여러가지 스레드가 하나의 자원을 사용할때?
	동기화작업
		
static 변수나 메서드는 인스턴스를 생성하지 않아도 클래스 이름으로 호출할 수 있다.

컬렉션 프레임워크
	제네릭 : 모든 종류의 타입을 다루기 위해 
		=> 클래스, 메소드를 일반화된 타입매개변수<T>를 이용하여 선언하는 방법 
		여러 참조 자료형이 쓰일 수 있는 곳에 특정한 자료형을 지정하지 않고, 
		클래스나 메서드를 정의한 후 사용하는 시점에 어떤 자료형을 사용할 것인지 지정하는 방식
	- 클래스명<T> : 참조자료형이 정해져있지 않음
	- <> : 모형자
	- T : type의 약자. 자료형 매개변수
	- 나중에 클래스를 사용할 때 T 위치에 실제 사용할 자료형을 지정한다.
	- 원하는 모형으로 찍어내듯이 만들수있다?
	제네릭(모형자) -> 템플릿(모형자)
	generic <> angle blanket

컬렉션 프레임워크
	(Vector, ArrayList, Map, Set)

컬렉션(collection)
	프로그램 개발에 필요한 기초적인 자료구조들
  	제네릭 기법으로 구현됨
  		컬렉션 클래스나 인터페이스에 <E>, <k>, <v> (타입매개변수)항상 포함됨
  		=> 컬렉션이 다룰 수 있는 원소 타입을 여러 종류로 변신할 수 있도록 일반화 시키기 위한 작업
  		컬렉션이 다룰 수 있는 원소의 타입을 여러 종류로 변신할 수 있도록 일반화 시키기 위해 컬렉션을 생성하고 
  		사용할 때는 오직 한 타입 값만 저장 가능
	컬렉션의 요소는 객체들만 가능함
	int, double, char 등 기본타입의 데이터를 컬렉션의 요소로 불가능
	가변크기의 컨테이너이다. 데이터 삽입, 삭제 시 편리하다
	제네릭 메서드
 		public <자료형 매개변수> 반환형 메서드 이름(자료형 매개변수 ...){ }
  
List
	순차적인 자료 관리에 주로 사용
	순서있고 중복 허용한다
	ArrayList와 Vector 의 차이는 동기화 지원 여부
		동기화
			두 개 이상의 스레드가 동시에 Vector를 사용할 때 오류가 나지 않도록 실행 순서를 보장하는 것
ArrayList
	자바에서 배열을 구현한 대표 클래스
		ArrayList, Vector, LinkedList
	기본 배열은 항상 배열 길이를 정하고 시작, 배열을 사용 중에는 배열 길이를 변경 할 수 없다.
	객체 배열을 좀 더 쉽게 사용할 수 있도록 객체 배열 클래스 ArrayList를 제공
	
Set
	집합
	순서 상관없고 중복 허용하지 않는다
HashSet 클래스
	hashCode()
		자바에서 두 인스턴스가 같다면 hashCode() 에서 반환하는 해시코드값이 같아야 한다.
	equals(), hashCode()
		Object 클래스에서는 논리적으로 같은 객체를 구현하기 위해 equals() 메서드와 hashCode() 메서드가 재정의 되어 있다.
	만든 클래스에서도 equals() 메서드와 hashCode() 메서드를 재정의 하여 같은 객체임을 구현해야 한다.
TreeSet 클래스
	자료의 중복을 허용하지 않으면서 출력 결과 값을 정렬하는 클래스
	정렬을 구현해주는 인터페이스
		Comparable 인터페이스와 Comparator 인터페이스
		vompareTo() 의 반환값은 정수값이고,
		비교하는 두 값 중 this 값이 더 크면 양수, this 값이 더 작으면 음수를 반환하여 내림차순으로 정렬한다.
	
Map
	key-value 쌍으로 이루워진 자료 관리에 유용하다.
	key 값은 중복 될 수 없다.
	검색용 자료 구조
HashMap
	Map 인터페이스를 구현한 클래스 중 가장 많이 사용
	새로운 key-value 자료가 입력되거나, key를 알고 있는 상태에서 value 를 검색
	자료 추가 속도, 검색속도가 빠르다
	containsKey()
		HashMap에 매개변수로 받은 키 값이 있으면.
	
Iterator
	요소를 순회할 때 사용하는 메서드
	순차적으로 반환
	boolean hasNext()
		이후에 요소가 더 있는지 체크하는 메서드, 요소가 있으면 true를 반환
	E next()
		다음에 있는 요소를 반환
	
	
	
	
	
	
	  
  
  